{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf400
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Menlo-Regular;\f2\fnil\fcharset0 Menlo-Italic;
\f3\fnil\fcharset0 Menlo-Bold;}
{\colortbl;\red255\green255\blue255;\red31\green31\blue36;\red253\green143\blue63;\red252\green106\blue93;
\red108\green121\blue134;\red252\green95\blue163;\red255\green255\blue255;\red122\green200\blue182;\red150\green134\blue245;
\red153\green232\blue213;\red174\green243\blue125;}
{\*\expandedcolortbl;;\csgenericrgb\c12054\c12284\c14131;\csgenericrgb\c99131\c56076\c24611;\csgenericrgb\c98912\c41558\c36568;
\csgenericrgb\c42394\c47462\c52518;\csgenericrgb\c98839\c37355\c63833;\csgenericrgb\c100000\c100000\c100000;\csgenericrgb\c47716\c78607\c71403;\csgenericrgb\c58752\c52717\c95948;
\csgenericrgb\c59926\c90967\c83488;\csgenericrgb\c68215\c95290\c48909;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \cb2 \
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f1 \cf3 #include \cf4 <iostream>
\f0 \cf0 \

\f1 \cf3 #include \cf4 <cmath>
\f0 \cf0 \

\f1 \cf3 #include \cf4 <vector>
\f0 \cf0 \

\f1 \cf3 #include \cf4 <iomanip>\cf3  
\f2\i \cf5 // so that we can use setprecision
\f0\i0 \cf0 \

\f3\b \cf6 using
\f1\b0 \cf7  
\f3\b \cf6 namespace
\f1\b0 \cf7  \cf8 std\cf7 ;
\f0 \cf0 \
\

\f3\b \cf6 double
\f1\b0 \cf7  step_euler(
\f3\b \cf6 const
\f1\b0 \cf7  
\f3\b \cf6 double
\f1\b0 \cf7  y, 
\f3\b \cf6 const
\f1\b0 \cf7  
\f3\b \cf6 double
\f1\b0 \cf7  t,
\f0 \cf0 \

\f1 \cf7                   
\f3\b \cf6 const
\f1\b0 \cf7  
\f3\b \cf6 double
\f1\b0 \cf7  h, 
\f3\b \cf6 double
\f1\b0 \cf7  f(
\f3\b \cf6 const
\f1\b0 \cf7  
\f3\b \cf6 double
\f1\b0 \cf7 , 
\f3\b \cf6 const
\f1\b0 \cf7  
\f3\b \cf6 double
\f1\b0 \cf7 )) \{
\f0 \cf0 \

\f1 \cf7     
\f3\b \cf6 const
\f1\b0 \cf7  
\f3\b \cf6 double
\f1\b0 \cf7  d0 = f(y, t);
\f0 \cf0 \

\f1 \cf7     
\f3\b \cf6 return
\f1\b0 \cf7  y + h*d0;
\f0 \cf0 \

\f1 \cf7 \}
\f0 \cf0 \
\

\f3\b \cf6 double
\f1\b0 \cf7  f_exp(
\f3\b \cf6 const
\f1\b0 \cf7  
\f3\b \cf6 double
\f1\b0 \cf7  y, 
\f3\b \cf6 const
\f1\b0 \cf7  
\f3\b \cf6 double
\f1\b0 \cf7  t) \{
\f0 \cf0 \

\f1 \cf7     
\f3\b \cf6 const
\f1\b0 \cf7  
\f3\b \cf6 double
\f1\b0 \cf7  r = \cf9 1.2\cf7 ;
\f0 \cf0 \

\f1 \cf7     
\f3\b \cf6 return
\f1\b0 \cf7  r*y;
\f0 \cf0 \

\f1 \cf7 \}
\f0 \cf0 \
\

\f3\b \cf6 int
\f1\b0 \cf7  main() \{
\f0 \cf0 \

\f1 \cf7     
\f0 \cf0 \

\f1 \cf7     
\f3\b \cf6 const
\f1\b0 \cf7  
\f3\b \cf6 double
\f1\b0 \cf7  t0 = \cf9 1.0\cf7 ;
\f0 \cf0 \

\f1 \cf7     
\f3\b \cf6 const
\f1\b0 \cf7  
\f3\b \cf6 double
\f1\b0 \cf7  T = \cf9 5.0\cf7 ;
\f0 \cf0 \

\f1 \cf7     
\f3\b \cf6 const
\f1\b0 \cf7  
\f3\b \cf6 double
\f1\b0 \cf7  y0 = \cf9 2.5\cf7 ;
\f0 \cf0 \

\f1 \cf7     
\f0 \cf0 \

\f1 \cf7     
\f3\b \cf6 const
\f1\b0 \cf7  
\f3\b \cf6 double
\f1\b0 \cf7  r = \cf9 1.2\cf7 ;
\f0 \cf0 \

\f1 \cf7     
\f3\b \cf6 const
\f1\b0 \cf7  
\f3\b \cf6 double
\f1\b0 \cf7  c = y0*\cf10 exp\cf7 (-r*t0);
\f0 \cf0 \

\f1 \cf7     \cf8 cout\cf7  << \cf4 "Exact\\t"\cf7  << \cf10 setprecision\cf7 (\cf9 12\cf7 ) << c*\cf10 exp\cf7 (r*T) << \cf10 endl\cf7  << \cf10 endl\cf7 ;
\f0 \cf0 \

\f1 \cf7     
\f0 \cf0 \

\f1 \cf7     
\f3\b \cf6 int
\f1\b0 \cf7  n = \cf9 10\cf7 ;
\f0 \cf0 \

\f1 \cf7     
\f3\b \cf6 double
\f1\b0 \cf7  eps = \cf9 1E-5\cf7 ; 
\f2\i \cf5 // tolerance for accuracy
\f0\i0 \cf0 \

\f1 \cf7     
\f3\b \cf6 double
\f1\b0 \cf7  E = \cf9 1\cf7 ; 
\f2\i \cf5 // to store relative accuracy
\f0\i0 \cf0 \

\f1 \cf7     
\f3\b \cf6 double
\f1\b0 \cf7  z = -\cf9 1\cf7 ; 
\f2\i \cf5 // to store previous value of y
\f0\i0 \cf0 \

\f1 \cf7     
\f3\b \cf6 bool
\f1\b0 \cf7  first=
\f3\b \cf6 true
\f1\b0 \cf7 ;
\f0 \cf0 \

\f1 \cf7     
\f3\b \cf6 do
\f1\b0 \cf7  \{
\f0 \cf0 \

\f1 \cf7         
\f3\b \cf6 const
\f1\b0 \cf7  
\f3\b \cf6 double
\f1\b0 \cf7  h = (T-t0)/
\f3\b \cf6 double
\f1\b0 \cf7 (n);
\f0 \cf0 \

\f1 \cf7         
\f0 \cf0 \

\f1 \cf7         
\f3\b \cf6 double
\f1\b0 \cf7  y = y0;
\f0 \cf0 \

\f1 \cf7         
\f3\b \cf6 double
\f1\b0 \cf7  t = t0;
\f0 \cf0 \

\f1 \cf7         
\f3\b \cf6 for
\f1\b0 \cf7  (
\f3\b \cf6 int
\f1\b0 \cf7  i = \cf9 0\cf7 ; i<n; i++) \{
\f0 \cf0 \

\f1 \cf7             y = \cf11 step_euler\cf7 (y, t, h, \cf11 f_exp\cf7 );
\f0 \cf0 \

\f1 \cf7             t += h; 
\f2\i \cf5 // its going to spit out the final value (our end approximation)
\f0\i0 \cf0 \

\f1 \cf7         \}
\f0 \cf0 \

\f1 \cf7         
\f3\b \cf6 if
\f1\b0 \cf7 (!first)\{ 
\f2\i \cf5 // this is so we can check that weve gone round at least once
\f0\i0 \cf0 \

\f1 \cf7            
\f2\i \cf5 // it wont set E if we havent gone round once
\f0\i0 \cf0 \

\f1 \cf7             
\f2\i \cf5 // so that the value of z used is from using the previous value of n
\f0\i0 \cf0 \

\f1 \cf7             E = \cf10 abs\cf7 ((y-z)/z); 
\f2\i \cf5 // this is gonna be used to test if the value changed much when we double the sample size compared to the last sample size
\f0\i0 \cf0 \

\f1 \cf7         \}
\f0 \cf0 \

\f1 \cf7         first = 
\f3\b \cf6 false
\f1\b0 \cf7 ;
\f0 \cf0 \

\f1 \cf7         z = y; 
\f2\i \cf5 // set z = final y so that we can use it in the next iteration
\f0\i0 \cf0 \

\f1 \cf7         n *= \cf9 2\cf7 ; 
\f2\i \cf5 // double the sample size
\f0\i0 \cf0 \

\f1 \cf7     
\f0 \cf0 \

\f1 \cf7     \} 
\f3\b \cf6 while
\f1\b0 \cf7  (E>=eps); 
\f2\i \cf5 // some predefined tolerance i.e. going to keep testing double the sample size until
\f0\i0 \cf0 \

\f1 \cf7                         
\f2\i \cf5 //the diff in values is smaller than our tolerance
\f0\i0 \cf0 \

\f1 \cf7     
\f0 \cf0 \

\f1 \cf7     \cf8 cout\cf7  << n << \cf4 "\\t"\cf7  << \cf10 setprecision\cf7 (\cf9 12\cf7 ) << z << \cf10 endl\cf7 ;
\f0 \cf0 \

\f1 \cf7 \}
\f0 \cf0 \
\
}