{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf400
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Menlo-Regular;\f2\fnil\fcharset0 Menlo-Bold;
\f3\fnil\fcharset0 Menlo-Italic;}
{\colortbl;\red255\green255\blue255;\red31\green31\blue36;\red253\green143\blue63;\red252\green106\blue93;
\red252\green95\blue163;\red255\green255\blue255;\red122\green200\blue182;\red145\green212\blue98;\red108\green121\blue134;
\red153\green232\blue213;\red150\green134\blue245;\red174\green243\blue125;}
{\*\expandedcolortbl;;\csgenericrgb\c12054\c12284\c14131;\csgenericrgb\c99131\c56076\c24611;\csgenericrgb\c98912\c41558\c36568;
\csgenericrgb\c98839\c37355\c63833;\csgenericrgb\c100000\c100000\c100000;\csgenericrgb\c47716\c78607\c71403;\csgenericrgb\c56799\c83212\c38450;\csgenericrgb\c42394\c47462\c52518;
\csgenericrgb\c59926\c90967\c83488;\csgenericrgb\c58752\c52717\c95948;\csgenericrgb\c68215\c95290\c48909;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \cb2 \
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f1 \cf3 #include \cf4 <iostream>
\f0 \cf0 \

\f1 \cf3 #include \cf4 <vector>
\f0 \cf0 \

\f1 \cf3 #include \cf4 <iomanip>
\f0 \cf0 \

\f2\b \cf5 using
\f1\b0 \cf6  
\f2\b \cf5 namespace
\f1\b0 \cf6  \cf7 std\cf6 ;
\f0 \cf0 \
\

\f2\b \cf5 struct
\f1\b0 \cf6  Mod_euler \{
\f0 \cf0 \

\f1 \cf6     \cf7 vector\cf6 <
\f2\b \cf5 double
\f1\b0 \cf6 > d0;
\f0 \cf0 \

\f1 \cf6     \cf7 vector\cf6 <
\f2\b \cf5 double
\f1\b0 \cf6 > d1;
\f0 \cf0 \

\f1 \cf6     Mod_euler(
\f2\b \cf5 const
\f1\b0 \cf6  
\f2\b \cf5 int
\f1\b0 \cf6  m) : \cf8 d0\cf6 (m), \cf8 d1\cf6 (m) \{\}
\f0 \cf0 \

\f1 \cf6     
\f0 \cf0 \

\f1 \cf6     
\f3\i \cf9 // this function fills in y1 with the estimate of y at time t+h
\f0\i0 \cf0 \

\f1 \cf6     
\f2\b \cf5 void
\f1\b0 \cf6  
\f2\b \cf5 operator
\f1\b0 \cf6 ()(
\f2\b \cf5 const
\f1\b0 \cf6  \cf7 vector\cf6 <
\f2\b \cf5 double
\f1\b0 \cf6 >& y, 
\f2\b \cf5 const
\f1\b0 \cf6  
\f2\b \cf5 double
\f1\b0 \cf6  t,
\f0 \cf0 \

\f1 \cf6                     
\f2\b \cf5 const
\f1\b0 \cf6  
\f2\b \cf5 double
\f1\b0 \cf6  h, \cf7 vector\cf6 <
\f2\b \cf5 double
\f1\b0 \cf6 >& y1,
\f0 \cf0 \

\f1 \cf6                     
\f2\b \cf5 void
\f1\b0 \cf6  f(
\f2\b \cf5 const
\f1\b0 \cf6  \cf7 vector\cf6 <
\f2\b \cf5 double
\f1\b0 \cf6 >&, 
\f2\b \cf5 const
\f1\b0 \cf6  
\f2\b \cf5 double
\f1\b0 \cf6 , \cf7 vector\cf6 <
\f2\b \cf5 double
\f1\b0 \cf6 >&)) \{
\f0 \cf0 \

\f1 \cf6         
\f0 \cf0 \

\f1 \cf6         
\f0 \cf0 \

\f1 \cf6         f(y, t, \cf8 d0\cf6 ); 
\f3\i \cf9 // give derivative function parameters
\f0\i0 \cf0 \

\f1 \cf6         
\f2\b \cf5 const
\f1\b0 \cf6  
\f2\b \cf5 int
\f1\b0 \cf6  m = y.\cf10 size\cf6 ();
\f0 \cf0 \

\f1 \cf6         
\f2\b \cf5 for
\f1\b0 \cf6  (
\f2\b \cf5 int
\f1\b0 \cf6  j = \cf11 0\cf6 ; j<m; j++) \{
\f0 \cf0 \

\f1 \cf6             y1[\cf10 j\cf6 ] = y[\cf10 j\cf6 ] + h*\cf8 d0\cf6 [\cf10 j\cf6 ];
\f0 \cf0 \

\f1 \cf6         \} 
\f3\i \cf9 // this is going to work out the next y-values for each eqn to be used in the next loop
\f0\i0 \cf0 \

\f1 \cf6         
\f0 \cf0 \

\f1 \cf6         f(y1, t+h, \cf8 d1\cf6 );
\f0 \cf0 \

\f1 \cf6         
\f2\b \cf5 for
\f1\b0 \cf6  (
\f2\b \cf5 int
\f1\b0 \cf6  j = \cf11 0\cf6 ; j<m; j++) \{
\f0 \cf0 \

\f1 \cf6             y1[\cf10 j\cf6 ] = y[\cf10 j\cf6 ] + h/\cf11 2.0\cf6 *(\cf8 d0\cf6 [\cf10 j\cf6 ] + \cf8 d1\cf6 [\cf10 j\cf6 ]);
\f0 \cf0 \

\f1 \cf6         \} 
\f3\i \cf9 // using the average of the current and next derivative in each respective equation to store the next point
\f0\i0 \cf0 \

\f1 \cf6     \}
\f0 \cf0 \

\f1 \cf6 \};
\f0 \cf0 \
\

\f2\b \cf5 void
\f1\b0 \cf6  f_sis(
\f2\b \cf5 const
\f1\b0 \cf6  \cf7 vector\cf6 <
\f2\b \cf5 double
\f1\b0 \cf6 > &y, 
\f2\b \cf5 const
\f1\b0 \cf6  
\f2\b \cf5 double
\f1\b0 \cf6  t, \cf9 /// ALL YOU NEED TO DO IS MODIFY THIS FOR A DIFFERENT TYPE OF QUESTION
\f0 \cf0 \

\f1 \cf6                                                         
\f3\i \cf9 // THIS IS GOING TO RETURN DERIVATIVES FOR EACH RESPECTIVE EQUATION
\f0\i0 \cf0 \

\f1 \cf6            \cf7 vector\cf6 <
\f2\b \cf5 double
\f1\b0 \cf6 > &dydt) \{
\f0 \cf0 \

\f1 \cf6     
\f2\b \cf5 const
\f1\b0 \cf6  
\f2\b \cf5 double
\f1\b0 \cf6  N = \cf11 10000.0\cf6 ;
\f0 \cf0 \

\f1 \cf6     
\f2\b \cf5 const
\f1\b0 \cf6  
\f2\b \cf5 double
\f1\b0 \cf6  alpha = \cf11 0.1\cf6 ;
\f0 \cf0 \

\f1 \cf6     
\f2\b \cf5 const
\f1\b0 \cf6  
\f2\b \cf5 double
\f1\b0 \cf6  beta = \cf11 3.0\cf6 *alpha/N;
\f0 \cf0 \

\f1 \cf6     
\f2\b \cf5 const
\f1\b0 \cf6  
\f2\b \cf5 double
\f1\b0 \cf6  S = y[\cf11 0\cf6 ];
\f0 \cf0 \

\f1 \cf6     
\f2\b \cf5 const
\f1\b0 \cf6  
\f2\b \cf5 double
\f1\b0 \cf6  I = y[\cf11 1\cf6 ];
\f0 \cf0 \

\f1 \cf6     
\f0 \cf0 \

\f1 \cf6     dydt[\cf11 0\cf6 ] = alpha*I-beta*S*I; 
\f3\i \cf9 // derivatives // 1st and 2nd equation
\f0\i0 \cf0 \

\f1 \cf6     dydt[\cf11 1\cf6 ] = beta*S*I - alpha*I;
\f0 \cf0 \

\f1 \cf6     
\f3\i \cf9 //**** would need to add the next differential equation here && make sure you change M below for the amount of eqns******
\f0\i0 \cf0 \

\f1 \cf6   
\f0 \cf0 \

\f1 \cf6 \}
\f0 \cf0 \
\

\f2\b \cf5 int
\f1\b0 \cf6  main() \{
\f0 \cf0 \

\f1 \cf6     \cf9 /// EQUATION SPECIFIC MODIFIABLE ////
\f0 \cf0 \

\f1 \cf6     \cf9 /// initial values of T
\f0 \cf0 \

\f1 \cf6     
\f2\b \cf5 const
\f1\b0 \cf6  
\f2\b \cf5 double
\f1\b0 \cf6  t0 = \cf11 0.0\cf6 ;
\f0 \cf0 \

\f1 \cf6     
\f2\b \cf5 const
\f1\b0 \cf6  
\f2\b \cf5 double
\f1\b0 \cf6  T = \cf11 200.0\cf6 ;
\f0 \cf0 \

\f1 \cf6     
\f0 \cf0 \

\f1 \cf6     \cf9 ////////// this part is for initial values of Y
\f0 \cf0 \

\f1 \cf6     
\f2\b \cf5 const
\f1\b0 \cf6  
\f2\b \cf5 int
\f1\b0 \cf6  m = \cf11 2\cf6 ; 
\f3\i \cf9 // number of equations or y's were dealing with
\f0\i0 \cf0 \

\f1 \cf6     \cf7 vector\cf6 <
\f2\b \cf5 double
\f1\b0 \cf6 > y0(m);
\f0 \cf0 \

\f1 \cf6     
\f2\b \cf5 const
\f1\b0 \cf6  
\f2\b \cf5 double
\f1\b0 \cf6  N = \cf11 10000.0\cf6 ;
\f0 \cf0 \

\f1 \cf6     y0[\cf11 0\cf6 ] = N - \cf11 1.0\cf6 ; 
\f3\i \cf9 // initial values of Y in each eqn
\f0\i0 \cf0 \

\f1 \cf6     y0[\cf11 1\cf6 ] = \cf11 1.0\cf6 ;
\f0 \cf0 \

\f1 \cf6     \cf9 ////////////
\f0 \cf0 \

\f1 \cf6     
\f3\i \cf9 // //////////// //////////// //////////// //////////// //////////// //////////// ////////////
\f0\i0 \cf0 \

\f1 \cf6     
\f0 \cf0 \

\f1 \cf6     
\f2\b \cf5 const
\f1\b0 \cf6  
\f2\b \cf5 int
\f1\b0 \cf6  n = \cf11 100\cf6 ; 
\f3\i \cf9 // number of strips
\f0\i0 \cf0 \

\f1 \cf6     
\f2\b \cf5 const
\f1\b0 \cf6  
\f2\b \cf5 double
\f1\b0 \cf6  h = (T-t0)/
\f2\b \cf5 double
\f1\b0 \cf6 (n);
\f0 \cf0 \

\f1 \cf6   
\f0 \cf0 \

\f1 \cf6     \cf8 Mod_euler\cf6  mod_euler(m); 
\f3\i \cf9 // feed constructor to set the vectors size depending on how many y'values / ODEs wer're dealing with
\f0\i0 \cf0 \

\f1 \cf6                             
\f3\i \cf9 // 2 equations would mean m=2 like in this case
\f0\i0 \cf0 \

\f1 \cf6     
\f0 \cf0 \

\f1 \cf6     
\f0 \cf0 \

\f1 \cf6     \cf7 vector\cf6 <
\f2\b \cf5 double
\f1\b0 \cf6 > y(m); 
\f3\i \cf9 // to hold current and next values of y for computation in modified euler algorithm
\f0\i0 \cf0 \

\f1 \cf6     \cf7 vector\cf6 <
\f2\b \cf5 double
\f1\b0 \cf6 > y1(m);
\f0 \cf0 \

\f1 \cf6     
\f0 \cf0 \

\f1 \cf6     
\f0 \cf0 \

\f1 \cf6     
\f0 \cf0 \

\f1 \cf6     
\f2\b \cf5 for
\f1\b0 \cf6  (
\f2\b \cf5 int
\f1\b0 \cf6  j = \cf11 0\cf6 ; j<m; j++) \{ 
\f3\i \cf9 // fill the holding vector of Y's with the starting values
\f0\i0 \cf0 \

\f1 \cf6         y[\cf10 j\cf6 ] = y0[\cf10 j\cf6 ];
\f0 \cf0 \

\f1 \cf6     \}
\f0 \cf0 \

\f1 \cf6     
\f0 \cf0 \

\f1 \cf6     
\f2\b \cf5 double
\f1\b0 \cf6  t = t0;
\f0 \cf0 \

\f1 \cf6     
\f2\b \cf5 for
\f1\b0 \cf6  (
\f2\b \cf5 int
\f1\b0 \cf6  i = \cf11 0\cf6 ; i<n; i++) \{
\f0 \cf0 \

\f1 \cf6         mod_euler(\cf12 y\cf6 , \cf12 t\cf6 , \cf12 h\cf6 , \cf12 y1\cf6 , \cf12 f_sis\cf6 ); 
\f3\i \cf9 // feed the struct for 2 equations
\f0\i0 \cf0 \

\f1 \cf6         
\f0 \cf0 \

\f1 \cf6         
\f3\i \cf9 // now the y would have been updated with the new value
\f0\i0 \cf0 \

\f1 \cf6         
\f2\b \cf5 for
\f1\b0 \cf6  (
\f2\b \cf5 int
\f1\b0 \cf6  j = \cf11 0\cf6 ; j<m; j++) \{ 
\f3\i \cf9 // now we want to set it equal to the old value to generate the next y value
\f0\i0 \cf0 \

\f1 \cf6             y[\cf10 j\cf6 ] = y1[\cf10 j\cf6 ];
\f0 \cf0 \

\f1 \cf6         \}
\f0 \cf0 \

\f1 \cf6         t += h; 
\f3\i \cf9 // next t
\f0\i0 \cf0 \

\f1 \cf6     \}
\f0 \cf0 \

\f1 \cf6     
\f0 \cf0 \

\f1 \cf6     
\f2\b \cf5 for
\f1\b0 \cf6  (
\f2\b \cf5 int
\f1\b0 \cf6  j = \cf11 0\cf6 ; j<m; j++) \{ 
\f3\i \cf9 // going to output the final values (final approximation)
\f0\i0 \cf0 \

\f1 \cf6         \cf7 cout\cf6  << y[\cf10 j\cf6 ] << \cf10 endl\cf6 ;
\f0 \cf0 \

\f1 \cf6     \}
\f0 \cf0 \

\f1 \cf6     
\f0 \cf0 \

\f1 \cf6     
\f2\b \cf5 const
\f1\b0 \cf6  
\f2\b \cf5 double
\f1\b0 \cf6  alpha = \cf11 0.1\cf6 ;
\f0 \cf0 \

\f1 \cf6     
\f2\b \cf5 const
\f1\b0 \cf6  
\f2\b \cf5 double
\f1\b0 \cf6  beta = \cf11 3.0\cf6 *alpha/N;
\f0 \cf0 \

\f1 \cf6     \cf7 cout\cf6  << \cf4 "\\nEquilibrium:\\n"\cf6 ;
\f0 \cf0 \

\f1 \cf6     \cf7 cout\cf6  << alpha/beta << \cf10 endl\cf6 ;
\f0 \cf0 \

\f1 \cf6     \cf7 cout\cf6  << N-alpha/beta << \cf10 endl\cf6 ;
\f0 \cf0 \

\f1 \cf6 \}
\f0 \cf0 \
\
}