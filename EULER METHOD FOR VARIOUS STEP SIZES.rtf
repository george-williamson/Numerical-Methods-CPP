{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf200
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;\f1\fswiss\fcharset0 Helvetica;\f2\fnil\fcharset0 Menlo-Italic;
\f3\fnil\fcharset0 Menlo-Bold;}
{\colortbl;\red255\green255\blue255;\red253\green143\blue63;\red31\green31\blue36;\red252\green106\blue93;
\red108\green121\blue134;\red252\green95\blue163;\red255\green255\blue255;\red122\green200\blue182;\red150\green134\blue245;
\red153\green232\blue213;\red174\green243\blue125;}
{\*\expandedcolortbl;;\csgenericrgb\c99131\c56076\c24611;\csgenericrgb\c12054\c12284\c14131;\csgenericrgb\c98912\c41558\c36568;
\csgenericrgb\c42394\c47462\c52518;\csgenericrgb\c98839\c37355\c63833;\csgenericrgb\c100000\c100000\c100000;\csgenericrgb\c47716\c78607\c71403;\csgenericrgb\c58752\c52717\c95948;
\csgenericrgb\c59926\c90967\c83488;\csgenericrgb\c68215\c95290\c48909;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab593
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f0\fs24 \cf2 \cb3 #include \cf4 <iostream>
\f1 \cf0 \

\f0 \cf2 #include \cf4 <cmath>
\f1 \cf0 \

\f0 \cf2 #include \cf4 <vector>
\f1 \cf0 \

\f0 \cf2 #include \cf4 <iomanip>\cf2  
\f2\i \cf5 // so that we can use setprecision
\f1\i0 \cf0 \

\f3\b \cf6 using
\f0\b0 \cf7  
\f3\b \cf6 namespace
\f0\b0 \cf7  \cf8 std\cf7 ;
\f1 \cf0 \
\

\f3\b \cf6 double
\f0\b0 \cf7  step_euler(
\f3\b \cf6 const
\f0\b0 \cf7  
\f3\b \cf6 double
\f0\b0 \cf7  y, 
\f3\b \cf6 const
\f0\b0 \cf7  
\f3\b \cf6 double
\f0\b0 \cf7  t, 
\f3\b \cf6 const
\f0\b0 \cf7  
\f3\b \cf6 double
\f0\b0 \cf7  h, 
\f3\b \cf6 double
\f0\b0 \cf7  f(
\f3\b \cf6 const
\f0\b0 \cf7  
\f3\b \cf6 double
\f0\b0 \cf7 , 
\f3\b \cf6 const
\f0\b0 \cf7  
\f3\b \cf6 double
\f0\b0 \cf7 )) \{ 
\f2\i \cf5 // function that deals with adding steps to generate each value of y
\f1\i0 \cf0 \

\f0 \cf7     
\f3\b \cf6 const
\f0\b0 \cf7  
\f3\b \cf6 double
\f0\b0 \cf7  d0 = f(y, t); 
\f2\i \cf5 // returns the value of the next step (one step)
\f1\i0 \cf0 \

\f0 \cf7     
\f3\b \cf6 return
\f0\b0 \cf7  y + h*d0;
\f1 \cf0 \

\f0 \cf7 \}
\f1 \cf0 \
\

\f3\b \cf6 double
\f0\b0 \cf7  f_exp(
\f3\b \cf6 const
\f0\b0 \cf7  
\f3\b \cf6 double
\f0\b0 \cf7  y, 
\f3\b \cf6 const
\f0\b0 \cf7  
\f3\b \cf6 double
\f0\b0 \cf7  t) \{ \cf5 /// function which returns the derivative
\f1 \cf0 \

\f0 \cf7                                                 \cf5 /// it is built to take both y and t - derivative doesn't depend on t in this case
\f1 \cf0 \

\f0 \cf7     
\f3\b \cf6 const
\f0\b0 \cf7  
\f3\b \cf6 double
\f0\b0 \cf7  r = \cf9 1.2\cf7 ;
\f1 \cf0 \

\f0 \cf7     
\f3\b \cf6 return
\f0\b0 \cf7  r*y;
\f1 \cf0 \

\f0 \cf7 \}
\f1 \cf0 \
\

\f3\b \cf6 int
\f0\b0 \cf7  main() \{
\f1 \cf0 \

\f0 \cf7     
\f1 \cf0 \

\f0 \cf7     
\f1 \cf0 \

\f0 \cf7     
\f2\i \cf5 //specific example conditions
\f1\i0 \cf0 \

\f0 \cf7     
\f3\b \cf6 const
\f0\b0 \cf7  
\f3\b \cf6 double
\f0\b0 \cf7  t0 = \cf9 1.0\cf7 ; 
\f2\i \cf5 // initial t (x-axis)
\f1\i0 \cf0 \

\f0 \cf7     
\f3\b \cf6 const
\f0\b0 \cf7  
\f3\b \cf6 double
\f0\b0 \cf7  T = \cf9 5.0\cf7 ; 
\f2\i \cf5 // final t (x-axis)
\f1\i0 \cf0 \

\f0 \cf7     
\f3\b \cf6 const
\f0\b0 \cf7  
\f3\b \cf6 double
\f0\b0 \cf7  y0 = \cf9 2.5\cf7 ; 
\f2\i \cf5 // (initial y (y-axis)
\f1\i0 \cf0 \

\f0 \cf7     
\f1 \cf0 \

\f0 \cf7     
\f3\b \cf6 const
\f0\b0 \cf7  
\f3\b \cf6 double
\f0\b0 \cf7  r = \cf9 1.2\cf7 ; 
\f2\i \cf5 // growth rate (specific to example)
\f1\i0 \cf0 \

\f0 \cf7     
\f3\b \cf6 const
\f0\b0 \cf7  
\f3\b \cf6 double
\f0\b0 \cf7  c = y0*\cf10 exp\cf7 (-r*t0); 
\f2\i \cf5 // value of C for particular solution
\f1\i0 \cf0 \

\f0 \cf7     \cf8 cout\cf7  << \cf4 "Exact\\t"\cf7  << \cf10 setprecision\cf7 (\cf9 12\cf7 ) << c*\cf10 exp\cf7 (r*T) << \cf10 endl\cf7  << \cf10 endl\cf7 ; 
\f2\i \cf5 // the exact value at the end point T
\f1\i0 \cf0 \

\f0 \cf7     
\f1 \cf0 \

\f0 \cf7     \cf8 vector\cf7 <
\f3\b \cf6 int
\f0\b0 \cf7 > nn = \{\cf9 10\cf7 ,\cf9 100\cf7 ,\cf9 1000\cf7 ,\cf9 10000\cf7 ,\cf9 100000\cf7 \}; 
\f2\i \cf5 // number of steps
\f1\i0 \cf0 \

\f0 \cf7     
\f1 \cf0 \

\f0 \cf7     
\f3\b \cf6 for
\f0\b0 \cf7  (
\f3\b \cf6 int
\f0\b0 \cf7  j = \cf9 0\cf7 ; j<nn.\cf10 size\cf7 (); j++) \{
\f1 \cf0 \

\f0 \cf7         
\f3\b \cf6 const
\f0\b0 \cf7  
\f3\b \cf6 int
\f0\b0 \cf7  n = nn[\cf10 j\cf7 ]; 
\f2\i \cf5 // for a number of steps j in the vector
\f1\i0 \cf0 \

\f0 \cf7         
\f3\b \cf6 const
\f0\b0 \cf7  
\f3\b \cf6 double
\f0\b0 \cf7  h = (T-t0)/
\f3\b \cf6 double
\f0\b0 \cf7 (n); 
\f2\i \cf5 // defn of h
\f1\i0 \cf0 \

\f0 \cf7         
\f1 \cf0 \

\f0 \cf7         
\f3\b \cf6 double
\f0\b0 \cf7  y = y0; 
\f2\i \cf5 // first y
\f1\i0 \cf0 \

\f0 \cf7         
\f3\b \cf6 double
\f0\b0 \cf7  t = t0; 
\f2\i \cf5 // first t
\f1\i0 \cf0 \

\f0 \cf7         
\f3\b \cf6 for
\f0\b0 \cf7  (
\f3\b \cf6 int
\f0\b0 \cf7  i = \cf9 0\cf7 ; i<n; i++) \{
\f1 \cf0 \

\f0 \cf7             y = \cf11 step_euler\cf7 (y, t, h, \cf11 f_exp\cf7 ); 
\f2\i \cf5 // for a specific number of steps its going to loop through generating all values until it teaches the final value T
\f1\i0 \cf0 \

\f0 \cf7             t += h; 
\f2\i \cf5 // add h so it can get to the next point - will do this for however many 'n' you have
\f1\i0 \cf0 \

\f0 \cf7         \} 
\f2\i \cf5 // return the value of the next step
\f1\i0 \cf0 \

\f0 \cf7         \cf8 cout\cf7  << n << \cf4 "\\t"\cf7  << \cf10 setprecision\cf7 (\cf9 12\cf7 ) <<  y << \cf10 endl\cf7 ;
\f1 \cf0 \

\f0 \cf7     \}
\f1 \cf0 \

\f0 \cf7     
\f2\i \cf5 // about 1 decimal place of accuracy is gained
\f1\i0 \cf0 \

\f0 \cf7     
\f2\i \cf5 // each time n is multiplied by 10
\f1\i0 \cf0 \

\f0 \cf7 \}
\f1 \cf0 \
}